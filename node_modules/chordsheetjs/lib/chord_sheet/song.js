'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _line = require('./line');

var _line2 = _interopRequireDefault(_line);

var _tag = require('./tag');

var _tag2 = _interopRequireDefault(_tag);

var _paragraph = require('./paragraph');

var _paragraph2 = _interopRequireDefault(_paragraph);

var _utilities = require('../utilities');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TITLE = 'title';
var SUBTITLE = 'subtitle';

var Song = function () {
  function Song() {
    var metaData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Song);

    this.lines = [];
    this.currentLine = null;
    this.paragraphs = [];
    this.currentParagraph = null;
    this.metaData = metaData;
  }

  _createClass(Song, [{
    key: 'chords',
    value: function chords(chr) {
      this.currentLine.chords(chr);
    }
  }, {
    key: 'lyrics',
    value: function lyrics(chr) {
      this.ensureLine();
      this.currentLine.lyrics(chr);
    }
  }, {
    key: 'addLine',
    value: function addLine() {
      this.ensureParagraph();
      this.flushLine();
      this.currentLine = (0, _utilities.pushNew)(this.lines, _line2.default);
      return this.currentLine;
    }
  }, {
    key: 'setCurrentLineType',
    value: function setCurrentLineType(type) {
      if (this.currentLine) {
        this.currentLine.type = type;
      }
    }
  }, {
    key: 'flushLine',
    value: function flushLine() {
      if (this.currentLine !== null) {
        if (this.currentLine.isEmpty()) {
          this.addParagraph();
        } else if (this.currentLine.hasContent()) {
          this.currentParagraph.addLine(this.currentLine);
        }
      }
    }
  }, {
    key: 'finish',
    value: function finish() {
      this.flushLine();
    }
  }, {
    key: 'addChordLyricsPair',
    value: function addChordLyricsPair() {
      this.ensureLine();
      return this.currentLine.addChordLyricsPair();
    }
  }, {
    key: 'ensureLine',
    value: function ensureLine() {
      if (this.currentLine === null) {
        this.addLine();
      }
    }
  }, {
    key: 'addParagraph',
    value: function addParagraph() {
      this.currentParagraph = (0, _utilities.pushNew)(this.paragraphs, _paragraph2.default);
      return this.currentParagraph;
    }
  }, {
    key: 'ensureParagraph',
    value: function ensureParagraph() {
      if (this.currentParagraph === null) {
        this.addParagraph();
      }
    }
  }, {
    key: 'addTag',
    value: function addTag(tagContents) {
      var tag = _tag2.default.parse(tagContents);

      if (tag.isMetaTag()) {
        this.metaData[tag.name] = tag.value;
      }

      this.ensureLine();
      this.currentLine.addTag(tag);

      return tag;
    }
  }, {
    key: 'clone',
    value: function clone() {
      var clonedSong = new Song();
      clonedSong.lines = this.lines.map(function (line) {
        return line.clone();
      });
      clonedSong.metaData = _extends({}, this.metaData);
      return clonedSong;
    }
  }, {
    key: 'bodyLines',
    get: function get() {
      if (this._bodyLines === undefined) {
        this._bodyLines = [].concat(_toConsumableArray(this.lines));

        while (!this._bodyLines[0].hasRenderableItems()) {
          this._bodyLines.shift();
        }
      }

      return this._bodyLines;
    }
  }, {
    key: 'title',
    get: function get() {
      return this.metaData[TITLE] || '';
    }
  }, {
    key: 'subtitle',
    get: function get() {
      return this.metaData[SUBTITLE] || '';
    }
  }]);

  return Song;
}();

exports.default = Song;